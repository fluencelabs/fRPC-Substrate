aqua RPC

import "@fluencelabs/aqua-lib/builtin.aqua"
import Subnet, Worker from "@fluencelabs/aqua-lib/subnet.aqua"

import "services.aqua"
use "deals.aqua"

import Logger, initPeerLogger from "logger.aqua"
import Balancer, randomBalancer, cycleBalancer from "balancer.aqua"
import onPeerCounter from "counter.aqua"
import timeRandom from "random.aqua"
import RPCEth, fromWorkerProvider from "eth_rpc.aqua"

import NumOp from "utils.aqua"

export randomLoadBalancingEth, roundRobinEth, quorumEth, QuorumChecker

data QuorumResult:
  value: string
  results: []JsonString
  error: string

service QuorumChecker("quorum"):
  check(results: []JsonString, minResults: u32) -> QuorumResult

func errorJsonString(msg: string) -> JsonString:
  <- JsonString(value = "", success = false, error = msg)

func getWorkers() -> []Worker, ?string:
  on INIT_PEER_ID via HOST_PEER_ID:
    deals <- Deals.get()
  dealId = deals.defaultWorker!.dealIdOriginal
  on HOST_PEER_ID:
    result <- Subnet.resolve(dealId)
  <- result.workers, result.error

func rpcCall{RPCEth}(method: string, jsonArgs: []string) -> JsonString:
  <- RPCEth.call(method, jsonArgs)

func balancedEthCall{Logger, Balancer}(method: string, jsonArgs: []string) -> JsonString:
  on HOST_PEER_ID:
    worker, provider <- Balancer.next()
    Logger.logWorker(worker)
    Logger.logCall(provider)
    Op.noop() -- dirty hack
    rpc <- fromWorkerProvider(worker, provider)
    result <- rpcCall{rpc}(method, jsonArgs)
  <- result

func randomLoadBalancingEth(uris: []string, method: string, jsonArgs: []string) -> JsonString:
  result: *JsonString

  workers, error <- getWorkers()
  if error != nil:
    result <- errorJsonString(error!)
  else:
    log <- initPeerLogger()
    random <- timeRandom()
    balancer <- randomBalancer{random}(workers, uris)
    result <- balancedEthCall{log, balancer}(method, jsonArgs)
  
  <- result!

func roundRobinEth(uris: []string, method: string, jsonArgs: []string, counterServiceId: string, counterPeerId: string) -> JsonString:
  result: *JsonString

  workers, error <- getWorkers()
  if error != nil:
    result <- errorJsonString(error!)
  else:
    log <- initPeerLogger()
    counter <- onPeerCounter(counterPeerId, counterServiceId)
    balancer <- cycleBalancer{counter}(workers, uris)
    result <- balancedEthCall{log, balancer}(method, jsonArgs)
  
  <- result!

func quorum(
  uris: []string, quorumNumber: u32, timeout: u32, method: string, jsonArgs: []string, quorumServiceId: string, quorumPeerId: string
) -> QuorumResult:
  results: *JsonString
  on HOST_PEER_ID:
    workers <- getWorkers()
    for worker <- workers par:
      on worker.worker_id! via worker.host_id:
        -- choose provider randomly
        timeP <- NumOp.identity(Peer.timestamp_ms())
        providerNumber = timeP % uris.length
        provider = uris[providerNumber]
        rpc <- fromWorkerProvider(worker, provider)
        results <- rpcCall{rpc}(method, jsonArgs)
    -- wait all results from all workers with timeout
    join results[workers.length - 1]
    par Peer.timeout(timeout, "")
  on quorumPeerId via HOST_PEER_ID:
    -- check all results that we got
    quorumResult <- QuorumChecker.check(results, quorumNumber)
  <- quorumResult

func quorumEth(uris: []string, quorumNumber: u32, timeout: u32, method: string, jsonArgs: []string, quorumServiceId: string, quorumPeerId: string) -> QuorumResult:
  <- quorum(uris, quorumNumber, timeout, method, jsonArgs, quorumServiceId, quorumPeerId)